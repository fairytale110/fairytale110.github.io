<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>ASCII 和 Hex 互转</title>
      <link href="/2020/06/23/Convert%20Hex%20to%20ASCII%20and%20ASCII%20to%20Hex/"/>
      <url>/2020/06/23/Convert%20Hex%20to%20ASCII%20and%20ASCII%20to%20Hex/</url>
      
        <content type="html"><![CDATA[<p>Many times we do need to convert the string values <strong>ASCII from/to Hex format</strong>. In this small, post I am giving you two small code snippets which you can utilize to convert a string from <strong>Hex to ASCII or ASCII to Hex</strong>, as you want.</p><p>Overall conversion logic looks like this:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Hex   --  Decimal  --  ASCII</span><br></pre></td></tr></table></figure><h2 id="Convert-ASCII-to-Hex"><a href="#Convert-ASCII-to-Hex" class="headerlink" title="Convert ASCII to Hex"></a>Convert ASCII to Hex</h2><p>It is done in following steps:</p><ol><li>Convert String to char array</li><li>Cast it to Integer</li><li>Use Integer.toHexString() to convert it to Hex</li></ol><h4 id="ASCII-to-Hex-Example-Code"><a href="#ASCII-to-Hex-Example-Code" class="headerlink" title="ASCII to Hex Example Code"></a>ASCII to Hex Example Code</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">private` `static` `String asciiToHex(String asciiValue)``&#123;``  ``char``[] chars = asciiValue.toCharArray();``  ``StringBuffer hex = ``new` `StringBuffer();``  ``for` `(``int` `i = ``0``; i &lt; chars.length; i++)``  ``&#123;``    ``hex.append(Integer.toHexString((``int``) chars[i]));``  ``&#125;``  ``return` `hex.toString();``&#125;</span><br></pre></td></tr></table></figure><h2 id="Convert-Hex-to-ASCII"><a href="#Convert-Hex-to-ASCII" class="headerlink" title="Convert Hex to ASCII"></a>Convert Hex to ASCII</h2><p>It is done in following steps:</p><ol><li>Cut the Hex value in 2 chars groups</li><li>Convert it to base 16 Integer using Integer.parseInt(hex, 16) and cast to char</li><li>Append all chars in StringBuilder</li></ol><h4 id="Hex-to-ASCII-Example-Code"><a href="#Hex-to-ASCII-Example-Code" class="headerlink" title="Hex to ASCII Example Code"></a>Hex to ASCII Example Code</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">private` `static` `String hexToASCII(String hexValue)``&#123;``  ``StringBuilder output = ``new` `StringBuilder(``&quot;&quot;``);``  ``for` `(``int` `i = ``0``; i &lt; hexValue.length(); i += ``2``)``  ``&#123;``    ``String str = hexValue.substring(i, i + ``2``);``    ``output.append((``char``) Integer.parseInt(str, ``16``));``  ``&#125;``  ``return` `output.toString();``&#125;</span><br></pre></td></tr></table></figure><p>Now let’s test above methods with sample input data.</p><h2 id="Complete-Example-for-Hex-to-ASCII-and-ASCII-to-Hex-Conversion"><a href="#Complete-Example-for-Hex-to-ASCII-and-ASCII-to-Hex-Conversion" class="headerlink" title="Complete Example for Hex to ASCII and ASCII to Hex Conversion"></a>Complete Example for Hex to ASCII and ASCII to Hex Conversion</h2><p>In this example, I am converting a string “//howtodoinjava.com” to first in hex format, and then convert that hex string to again in ASCII value. This converted ASCII value should be equal to original string i.e. “//howtodoinjava.com”.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HexAsciiConversionExamples</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">   </span>&#123;</span><br><span class="line">      String demoString = <span class="string">"//howtodoinjava.com"</span>;</span><br><span class="line">      <span class="comment">//Original String</span></span><br><span class="line">      System.out.println(<span class="string">"Original String: "</span>+ demoString);</span><br><span class="line">       </span><br><span class="line">      String hexEquivalent = asciiToHex(demoString);</span><br><span class="line">      <span class="comment">//Hex value of original String</span></span><br><span class="line">      System.out.println(<span class="string">"Hex String: "</span>+ hexEquivalent);</span><br><span class="line">       </span><br><span class="line">      String asciiEquivalent = hexToASCII(hexEquivalent);</span><br><span class="line">      <span class="comment">//ASCII value obtained from Hex value</span></span><br><span class="line">      System.out.println(<span class="string">"Ascii String: "</span>+ asciiEquivalent);</span><br><span class="line">   &#125;</span><br><span class="line"> </span><br><span class="line">   <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> String <span class="title">asciiToHex</span><span class="params">(String asciiValue)</span></span></span><br><span class="line"><span class="function">   </span>&#123;</span><br><span class="line">      <span class="keyword">char</span>[] chars = asciiValue.toCharArray();</span><br><span class="line">      StringBuffer hex = <span class="keyword">new</span> StringBuffer();</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; chars.length; i++)</span><br><span class="line">      &#123;</span><br><span class="line">         hex.append(Integer.toHexString((<span class="keyword">int</span>) chars[i]));</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> hex.toString();</span><br><span class="line">   &#125;</span><br><span class="line"> </span><br><span class="line">   <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> String <span class="title">hexToASCII</span><span class="params">(String hexValue)</span></span></span><br><span class="line"><span class="function">   </span>&#123;</span><br><span class="line">      StringBuilder output = <span class="keyword">new</span> StringBuilder(<span class="string">""</span>);</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; hexValue.length(); i += <span class="number">2</span>)</span><br><span class="line">      &#123;</span><br><span class="line">         String str = hexValue.substring(i, i + <span class="number">2</span>);</span><br><span class="line">         output.append((<span class="keyword">char</span>) Integer.parseInt(str, <span class="number">16</span>));</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> output.toString();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>Output:</strong></p><blockquote><p>Original String: //howtodoinjava.com<br>Hex String: 687474703a2f2f686f77746f646f696e6a6176612e636f6d<br>Ascii String: //howtodoinjava.com</p></blockquote><p><strong>Happy Learning !!</strong></p><p>Reprinted <a href="https://howtodoinjava.com/java/convert-hex-to-ascii-and-ascii-to-hex/" target="_blank" rel="noopener">here</a></p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Android TensorFlow Lite 模型训练流程</title>
      <link href="/2020/06/08/Android%20TensorFlow%20%E6%A8%A1%E5%9E%8B%E8%AE%AD%E7%BB%83%E6%B5%81%E7%A8%8B/"/>
      <url>/2020/06/08/Android%20TensorFlow%20%E6%A8%A1%E5%9E%8B%E8%AE%AD%E7%BB%83%E6%B5%81%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<blockquote><p>参考文档：</p><p>官方文档：</p><p><a href="https://www.tensorflow.org/lite/examples" target="_blank" rel="noopener">https://www.tensorflow.org/lite/examples</a></p><p><a href="https://zhuanlan.zhihu.com/p/80510273" target="_blank" rel="noopener">TensorFlow Object Detection API遇到的问题及解决</a></p><p>// 自动标注</p><p><a href="https://github.com/yuxitong/AutoMarKingTensorFlowPython" target="_blank" rel="noopener">https://github.com/yuxitong/AutoMarKingTensorFlowPython</a></p></blockquote><blockquote><p>// TensorFlow android demo 车道线 车辆 人脸 动作 骨架 识别 检测 抽烟 打电话 闭眼 睁眼 ：       </p><p><a href="https://github.com/yuxitong/TensorFlowAndroidDemo/issues?q=is%3Aissue+is%3Aclosed" target="_blank" rel="noopener">https://github.com/yuxitong/TensorFlowAndroidDemo/issues?q=is%3Aissue+is%3Aclosed</a></p><p>// Deploying a TensorFlow model to Android （SO形式 有点年代）</p><p><a href="https://medium.com/joytunes/deploying-a-tensorflow-model-to-android-69d04d1b0cba" target="_blank" rel="noopener">https://medium.com/joytunes/deploying-a-tensorflow-model-to-android-69d04d1b0cba</a></p><p>// Android TensorFlow Machine Learning Example （SO形式）</p><p><a href="https://blog.mindorks.com/android-tensorflow-machine-learning-example-ff0e9b2654cc" target="_blank" rel="noopener">https://blog.mindorks.com/android-tensorflow-machine-learning-example-ff0e9b2654cc</a></p><p>// Training and serving a realtime mobile object detector in 30 minutes with Cloud TPUs （靠谱）</p><p><a href="https://medium.com/tensorflow/training-and-serving-a-realtime-mobile-object-detector-in-30-minutes-with-cloud-tpus-b78971cf1193" target="_blank" rel="noopener">https://medium.com/tensorflow/training-and-serving-a-realtime-mobile-object-detector-in-30-minutes-with-cloud-tpus-b78971cf1193</a></p></blockquote><blockquote><p>使用TensorFlow Lite将ssd_mobilenet移植至安卓客户端：靠谱</p></blockquote><blockquote><p><a href="https://blog.csdn.net/qq_26535271/article/details/83031412" target="_blank" rel="noopener">https://blog.csdn.net/qq_26535271/article/details/83031412</a></p><h4 id="官方或本地移动模型教程："><a href="#官方或本地移动模型教程：" class="headerlink" title="官方或本地移动模型教程："></a>官方或本地移动模型教程：</h4><p><code>https://github.com/tensorflow/models/blob/master/research/object_detection/g3doc/running_on_mobile_tensorflowlite.md</code></p></blockquote><blockquote><p>模型测试 + 模型转换，靠谱：</p></blockquote><blockquote><p><code>https://blog.csdn.net/weixin_43056275/article/details/105225089?depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-6&amp;utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-6#31_config_32</code></p></blockquote><blockquote><p><a href="https://blog.csdn.net/chenmaolin88/article/details/79357263" target="_blank" rel="noopener">https://blog.csdn.net/chenmaolin88/article/details/79357263</a></p></blockquote><blockquote><p>模型转换参考：量化建议</p><p><a href="https://www.jianshu.com/p/71de8a49efd4" target="_blank" rel="noopener">https://www.jianshu.com/p/71de8a49efd4</a></p></blockquote><blockquote><p>量化例子，参考</p><p><code>https://blog.csdn.net/angela_12/article/details/85000072?depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromBaidu-1&amp;utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromBaidu-1</code></p></blockquote><blockquote><p>ERR:</p><p>OOM when allocating tensor of shape [3,3,432,1] and type float</p><p>​     [[node gradients/zeros_144 (defined at /tensorflow/models/research/object_detection/model_lib.py:413) ]]</p><p>代码中使用的<strong>batch_size</strong>是10，改小为5</p><p><a href="https://github.com/tensorflow/models/issues/1993" target="_blank" rel="noopener">https://github.com/tensorflow/models/issues/1993</a></p><p>ERROR:</p><p>not a valid absolute pattern (absolute target patterns must start with exactly two slashes</p><p>路径用绝对路径， output 和 input 路径用 单引号起来的绝对路径</p></blockquote><p>0、删除 ~/train_ssd_mobilenet/roadsign_data/PascalVOC/ImageSets 里的Main文件夹</p><p>   删除 ~/train_ssd_mobilenet/roadsign_data/  tfrecords 文件夹</p><p>方置 图片和xml标注文集到 ~/train_ssd_mobilenet/roadsign_data/PascalVOC 对应文件夹</p><p>修改 :~/train_ssd_mobilenet/roadsign_data 下的 roadsign_label_map.pbtxt文集为自己的label</p><blockquote><p>修改配置文集，如果有必要，</p><p>配置文集原始位置：<code>/home/ubuntu/tensorflow/models/research/object_detection/samples/configs/</code></p><p>参考帖子：<code>https://blog.csdn.net/qq_26535271/article/details/84930868</code></p></blockquote><p>1、准备数据集、编译</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">cd ~/train_ssd_mobilenet</span><br><span class="line">//生成 ~/train_ssd_mobilenet/roadsign_data/PascalVOC/ImageSets  trainval.txt</span><br><span class="line">python3 build1_trainval.py </span><br><span class="line">// 生成  :~/train_ssd_mobilenet/roadsign_data/tfrecords</span><br><span class="line">python3 build2_tf_record.py</span><br></pre></td></tr></table></figure><p>1.1 训练配置选择：</p><p><a href="https://github.com/tensorflow/models/blob/master/research/object_detection/g3doc/detection_model_zoo.md" target="_blank" rel="noopener">https://github.com/tensorflow/models/blob/master/research/object_detection/g3doc/detection_model_zoo.md</a></p><p>// TODO 制作数据集的时候忘了对数据打乱顺序。图片是按第0、1、顺序排放的，所以训练的时候是会出问题的，一定要shuffle数据集 <code>shuffle=true</code></p><p>2、训练：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">python3 ~/tensorflow/models/research/object_detection/model_main.py --alsologtostderr --model_dir=resnet-042401 --pipeline_config_path=./ssd_mobilenet_v1_0.75_depth_quantized_300x300_coco14_sync_2018_07_18/pipeline.config </span><br><span class="line"></span><br><span class="line">// PC版 fast rcnn</span><br><span class="line">python3 ~/tensorflow/models/research/object_detection/model_main.py --alsologtostderr --model_dir=resnet-0530 --pipeline_config_path=./faster_rcnn_resnet101_coco.config</span><br><span class="line"></span><br><span class="line">// 换成tensorflow samples里面的config，目前正常</span><br><span class="line">python3 ~/tensorflow/models/research/object_detection/model_main.py --alsologtostderr --model_dir=resnet-0523 --pipeline_config_path=ssd_mobilenet_v2_quantized_300x300_coco.config \</span><br><span class="line">--num_train_steps=300000 --num_eval_steps=30</span><br><span class="line"></span><br><span class="line">// 可以不要</span><br><span class="line">--num_train_steps=100000        </span><br><span class="line"></span><br><span class="line">// 可以不要</span><br><span class="line">--num_eval_steps=20</span><br></pre></td></tr></table></figure><blockquote><h5 id="config提示："><a href="#config提示：" class="headerlink" title="config提示："></a>config提示：</h5><p><code>eval_config</code>:</p><p><code>num_examples</code>：想要验证的图片数量</p><p><code>max_evals</code>：验证循环次数/home/ubuntu/GoogleAPI/models/research/object_detection</p><p><code>metrics_set</code>：选择验证的方式，有以下几个选项（在research/object_detection/legacy/evaluator.py中）</p><p>配置文件调参 参考：</p><p><a href="https://www.sohu.com/a/238172351_100177858" target="_blank" rel="noopener">https://www.sohu.com/a/238172351_100177858</a>  </p><p><a href="https://www.cnblogs.com/jwcz/p/11799507.html" target="_blank" rel="noopener">https://www.cnblogs.com/jwcz/p/11799507.html</a></p><p><a href="https://github.com/tensorflow/models/blob/abd504235f3c2eed891571d62f0a424e54a2dabc/research/object_detection/protos/eval.proto#L8" target="_blank" rel="noopener">https://github.com/tensorflow/models/blob/abd504235f3c2eed891571d62f0a424e54a2dabc/research/object_detection/protos/eval.proto#L8</a></p></blockquote><blockquote><p>查看进度 <code>tensorboard --logdir resnet-042401</code> </p></blockquote><p>3、导出模型</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">python3 ~/tensorflow/models/research/object_detection/export_tflite_ssd_graph.py \</span><br><span class="line">--pipeline_config_path=./ssd_mobilenet_v2_quantized_300x300_coco.config \</span><br><span class="line">--trained_checkpoint_prefix=./resnet-0523/model.ckpt-500000 \</span><br><span class="line">--output_directory=./output-0523/tflite \</span><br><span class="line">--add_postprocessing_op=true \</span><br><span class="line">--max_detections=1000</span><br><span class="line"></span><br><span class="line">// max_detections 期望检测出来的物品最多多少个</span><br></pre></td></tr></table></figure><blockquote><p>PC 模型导出:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; python3 ~/tensorflow/models/research/object_detection/export_inference_graph.py --input_type image_tensor --pipeline_config_path=./faster_rcnn_resnet101_coco.config --trained_checkpoint_prefix ./resnet-0415/model.ckpt-104947  --output_directory .</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><p>4、转换成tflite模型</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">bazel run -c opt tensorflow/lite/toco:toco -- \</span><br><span class="line">--input_file=&apos;/home/ubuntu/train_ssd_mobilenet/output-0523/tflite/tflite_graph.pb&apos; \</span><br><span class="line">--output_file=&apos;/home/ubuntu/train_ssd_mobilenet/output-0523/tflite/detect.tflite&apos; \</span><br><span class="line">--input_format=TENSORFLOW_GRAPHDEF --output_format=TFLITE \</span><br><span class="line">--input_shapes=1,900,900,3 \</span><br><span class="line">--input_arrays=normalized_input_image_tensor \</span><br><span class="line">--output_arrays=&apos;TFLite_Detection_PostProcess&apos;,&apos;TFLite_Detection_PostProcess:1&apos;,&apos;TFLite_Detection_PostProcess:2&apos;,&apos;TFLite_Detection_PostProcess:3&apos;  \</span><br><span class="line">--inference_type=QUANTIZED_UINT8 \</span><br><span class="line">--mean_values=128.0 \</span><br><span class="line">--std_values=128.0 \</span><br><span class="line">--change_concat_input_ranges=false \</span><br><span class="line">--allow_custom_ops</span><br></pre></td></tr></table></figure><blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt; 这个参数不确定，未测试 :</span><br><span class="line">&gt; --default_ranges_min=0 --default_ranges_max=6</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><h4 id="模型本地测试"><a href="#模型本地测试" class="headerlink" title="模型本地测试"></a>模型本地测试</h4><blockquote><p>仅适用于fast 训练的模型?， mobilenet训练的模型pb报400)</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tensorflow_model_server --rest_api_port=9000  --model_name=aaa --model_base_path=/home/ubuntu/train_ssd_mobilenet/output-042401</span><br></pre></td></tr></table></figure><blockquote><p>rcnn_web中转服务,依赖包; pip3 python3.6 </p><p>Keras (2.3.1)<br>Keras-Applications (1.0.8)<br>Keras-Preprocessing (1.1.0)</p><p>Flask (1.1.2)</p><p>否则无法运行</p></blockquote><h5 id="部署服务器"><a href="#部署服务器" class="headerlink" title="部署服务器"></a>部署服务器</h5><blockquote><ul><li><p>安装 pip3 install gunicorn</p></li><li><p><code>gunicorn [OPTIONS] 模块名：变量名</code></p></li></ul><p><code>gunicorn -b 0.0.0.0:5000 -w 9 wsgi:app</code></p><ul><li><p>阿里云ECS ubuntu无法找到gunicorn，卸载后，安装gunicorn3</p><p><code>gunicorn3 -b xxxx</code></p></li></ul></blockquote><p>5、修改官方demo文件：</p><p>参考demo <a href="https://github.com/fairytale110/Camera2WithTFLite" target="_blank" rel="noopener">https://github.com/fairytale110/Camera2WithTFLite</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">TFLiteObjectDetectionAPIModel.java</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"> // in label file and class labels start from 1 to number_of_classes+1,</span><br><span class="line">       // while outputClasses correspond to class index from 0 to number_of_classes</span><br><span class="line">       int labelOffset = 1;</span><br><span class="line">-      recognitions.add(</span><br><span class="line">-          new Recognition(</span><br><span class="line">-              &quot;&quot; + i,</span><br><span class="line">-              labels.get((int) outputClasses[0][i] + labelOffset),</span><br><span class="line">-              outputScores[0][i],</span><br><span class="line">-              detection));</span><br><span class="line">+        final int classLabel = (int) outputClasses[0][i] + labelOffset;</span><br><span class="line">+        if (inRange(classLabel, labels.size(), 0) &amp;&amp; inRange(outputScores[0][i], 1, 0)) &#123;</span><br><span class="line">+            recognitions.add(</span><br><span class="line">+                    new Recognition(</span><br><span class="line">+                            &quot;&quot; + i,</span><br><span class="line">+                            labels.get(classLabel),</span><br><span class="line">+                            outputScores[0][i],</span><br><span class="line">+                            detection));</span><br><span class="line">+        &#125;</span><br><span class="line">     &#125;</span><br><span class="line">     Trace.endSection(); // &quot;recognizeImage&quot;</span><br><span class="line">     return recognitions;</span><br><span class="line">   &#125;</span><br><span class="line"> </span><br><span class="line">+  private boolean inRange(float number, float max, float min) &#123;</span><br><span class="line">+    return number &lt; max &amp;&amp; number &gt;= min;</span><br><span class="line">+  &#125;</span><br><span class="line">+</span><br></pre></td></tr></table></figure><h2 id="遇到过的问题"><a href="#遇到过的问题" class="headerlink" title="遇到过的问题"></a>遇到过的问题</h2><h4 id="Cannot-copy-between-a-TensorFlowLite-tensor-with-shape-https-github-com-tensorflow-tensorflow-issues-29054"><a href="#Cannot-copy-between-a-TensorFlowLite-tensor-with-shape-https-github-com-tensorflow-tensorflow-issues-29054" class="headerlink" title="[Cannot copy between a TensorFlowLite tensor with shape][https://github.com/tensorflow/tensorflow/issues/29054]"></a>[Cannot copy between a TensorFlowLite tensor with shape][<a href="https://github.com/tensorflow/tensorflow/issues/29054]" target="_blank" rel="noopener">https://github.com/tensorflow/tensorflow/issues/29054]</a></h4><p>解决方法：<a href="https://github.com/tensorflow/tensorflow/issues/22106" target="_blank" rel="noopener">https://github.com/tensorflow/tensorflow/issues/22106</a></p><h4 id="WARNING-tensorflow-Ignoring-ground-truth-with-image-id-558212937-since-it-was-previously-added"><a href="#WARNING-tensorflow-Ignoring-ground-truth-with-image-id-558212937-since-it-was-previously-added" class="headerlink" title="WARNING:tensorflow:Ignoring ground truth with image id 558212937 since it was previously added"></a>WARNING:tensorflow:Ignoring ground truth with image id 558212937 since it was previously added</h4><p>解决办法：<br>把config文件eval_config部分的num_examples和训练代码的num_eval_steps都改为和测试集图片的数量一样或者更少就可以了（我的测试集图片有100张，我的两个地方都改成了100）</p><p><img src="https://img-blog.csdnimg.cn/20200409222757516.png" alt="config文件的num_examples"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">config文件的num_examples</span><br><span class="line"></span><br><span class="line">python object_detection/model_main.py \</span><br><span class="line">    --pipeline_config_path=object_detection/training/ssd_mobilenet_v1_coco.config \</span><br><span class="line">    --model_dir=object_detection/training \</span><br><span class="line">    --num_train_steps=50000 \</span><br><span class="line">    --num_eval_steps=100 \</span><br><span class="line">    --alsologtostderr</span><br></pre></td></tr></table></figure><p>原文链接：<a href="https://blog.csdn.net/weixin_46127907/java/article/details/105421607" target="_blank" rel="noopener">https://blog.csdn.net/weixin_46127907/java/article/details/105421607</a></p><h4 id="Invalid-argument-ValueError-Category-stats-do-not-exist-Traceback-most-recent-call-last"><a href="#Invalid-argument-ValueError-Category-stats-do-not-exist-Traceback-most-recent-call-last" class="headerlink" title="Invalid argument: ValueError: Category stats do not exist Traceback (most recent call last)"></a>Invalid argument: ValueError: Category stats do not exist Traceback (most recent call last)</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">tensorflow.python.framework.errors_impl.OutOfRangeError: 2 root error(s) found.</span><br><span class="line">  (0) Out of range: End of sequence</span><br><span class="line"> [[&#123;&#123;node IteratorGetNext&#125;&#125;]]</span><br><span class="line">  (1) Out of range: End of sequence</span><br><span class="line"> [[&#123;&#123;node IteratorGetNext&#125;&#125;]]</span><br><span class="line"> [[Postprocessor/BatchMultiClassNonMaxSuppression/MultiClassNonMaxSuppression/Shape_8/_4689]]</span><br></pre></td></tr></table></figure><p>原因：未知</p><p>解决方案：换为tensorflow带的同名config文件</p><h4 id="AssertionError-Bad-argument-number-for-Name-3-expecting-4"><a href="#AssertionError-Bad-argument-number-for-Name-3-expecting-4" class="headerlink" title="AssertionError: Bad argument number for Name: 3, expecting 4"></a>AssertionError: Bad argument number for Name: 3, expecting 4</h4><p>原因：网上说的和gats版本有关？没官暂时</p><h4 id="OOM-when-allocating-tensor-with-shape-20-32-300-300-and-type-float"><a href="#OOM-when-allocating-tensor-with-shape-20-32-300-300-and-type-float" class="headerlink" title="OOM when allocating tensor with shape[20,32,300,300] and type float"></a>OOM when allocating tensor with shape[20,32,300,300] and type float</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"> Allocator (GPU_0_bfc) ran out of memory trying to allocate 2.41GiB with freed_by_count=0. The caller indicates that this is not a failure, but may mean that there could be performance gains if more memory were available.</span><br><span class="line">2020-04-25 11:56:55.277922: W tensorflow/core/common_runtime/bfc_allocator.cc:237]</span><br></pre></td></tr></table></figure><p>解决方案：减小<code>batch_size</code></p><h4 id="Ignoring-detection-with-image-id-1471494072-since-it-was-previously-added"><a href="#Ignoring-detection-with-image-id-1471494072-since-it-was-previously-added" class="headerlink" title="Ignoring detection with image id 1471494072 since it was previously added"></a>Ignoring detection with image id 1471494072 since it was previously added</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">W0425 14:46:33.695297 139864167134976 coco_evaluation.py:139] Ignoring detection with image id 1471494072 since it was previously added</span><br></pre></td></tr></table></figure><h4 id="模型检测出来-出现重复的结果"><a href="#模型检测出来-出现重复的结果" class="headerlink" title="模型检测出来 出现重复的结果"></a>模型检测出来 出现重复的结果</h4><p>解析之后，一个物体会得到了多个定位的框，如何确定哪一个是我们需要的最准确的框呢？我们就要用到非极大值抑制，来抑制那些冗余的框：抑制的过程是一个迭代-遍历-消除的过程。</p><p>1，将所有框的得分排序，选中最高分及其对应的框</p><p>2，遍历其余的框，如果和当前最高分框的重叠面积(IOU)大于一定阈值，我们就将框删除。</p><p>3，从未处理的框中继续选一个得分最高的，重复上述过程。</p><h4 id="“-dev-kvm-device-permission-denied”"><a href="#“-dev-kvm-device-permission-denied”" class="headerlink" title="“/dev/kvm device: permission denied”"></a>“/dev/kvm device: permission denied”</h4><p>语法：chown [选项] 所有者 文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo chown 用户名 -R /dev/kvm</span><br></pre></td></tr></table></figure><hr><p>延伸资料:</p><p><a href="https://www.chainnews.com/articles/051424062222.htm" target="_blank" rel="noopener">https://www.chainnews.com/articles/051424062222.htm</a></p>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
          <category> TensorFlow </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 机器学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Android常用技巧</title>
      <link href="/2020/06/06/Android_tips/"/>
      <url>/2020/06/06/Android_tips/</url>
      
        <content type="html"><![CDATA[<h3 id="Google官方控件依赖版本查询"><a href="#Google官方控件依赖版本查询" class="headerlink" title="Google官方控件依赖版本查询"></a>Google官方控件依赖版本查询</h3><blockquote><p><a href="https://maven.google.com/web/index.html" target="_blank" rel="noopener">https://maven.google.com/web/index.html</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 技巧 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux使用技巧记录</title>
      <link href="/2020/06/06/Linux_usage_notes/"/>
      <url>/2020/06/06/Linux_usage_notes/</url>
      
        <content type="html"><![CDATA[<h3 id="apt临时代理"><a href="#apt临时代理" class="headerlink" title="apt临时代理"></a>apt临时代理</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo http_proxy=http://127.0.0.1:1081 apt xxx</span><br></pre></td></tr></table></figure><h3 id="sh文件无法执行"><a href="#sh文件无法执行" class="headerlink" title=".sh文件无法执行"></a>.sh文件无法执行</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">chmod +x xxx.sh</span><br><span class="line">./xxx.sh --user</span><br></pre></td></tr></table></figure><h3 id="pip-pip3-临时代理"><a href="#pip-pip3-临时代理" class="headerlink" title="pip/pip3 临时代理"></a>pip/pip3 临时代理</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip3 --proxy 127.0.0.1:1081 install opencv_python-4.2.0.34</span><br></pre></td></tr></table></figure><p>无权限时加上：<code>sudo -H</code></p><h3 id="创建带密码的压缩包"><a href="#创建带密码的压缩包" class="headerlink" title="创建带密码的压缩包"></a>创建带密码的压缩包</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">zip -re pycharm-jihuo-tools.zip pycharm-jihuo-tools</span><br></pre></td></tr></table></figure><h3 id="KVM-is-required-to-run-this-AVD-dev-kvm-devices-permission-denied-Grant-cuttrnt-user-access-to-dev-kvm"><a href="#KVM-is-required-to-run-this-AVD-dev-kvm-devices-permission-denied-Grant-cuttrnt-user-access-to-dev-kvm" class="headerlink" title="KVM is required to run this AVD, /dev/kvm devices: permission denied. Grant cuttrnt user access to /dev/kvm"></a>KVM is required to run this AVD, /dev/kvm devices: permission denied. Grant cuttrnt user access to /dev/kvm</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo chown username -R /dev/kvm</span><br></pre></td></tr></table></figure><h3 id="Android生成系统签名文件"><a href="#Android生成系统签名文件" class="headerlink" title="Android生成系统签名文件"></a>Android生成系统签名文件</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">./keytool-importkeypair -k [jks文件名] -p [jks的密码] -pk8 platform.pk8 -cert platform.x509.pem -alias [jks的别名]</span><br><span class="line"></span><br><span class="line">./keytool-importkeypair -k android_sign_file_jks.p12 -p pF_666 -pk8 platform.pk8 -cert platform.x509.pem -alias archives</span><br></pre></td></tr></table></figure><h3 id="bin-bash-M-bad-interpreter"><a href="#bin-bash-M-bad-interpreter" class="headerlink" title="/bin/bash^M: bad interpreter"></a>/bin/bash^M: bad interpreter</h3><blockquote><p>在执行shell脚本时提示这样的错误主要是由于shell脚本文件是dos格式，即每一行结尾以\r\n来标识，而unix格式的文件行尾则以\n来标识<br>cat -A filename 从显示结果可以判断，dos格式的文件行尾为^M$，unix格式的文件行尾为$；<br>使用linux命令dos2unix filename，直接把文件转换为unix格式</p></blockquote><h3 id="局域网文件夹带特定密码共享"><a href="#局域网文件夹带特定密码共享" class="headerlink" title="局域网文件夹带特定密码共享"></a>局域网文件夹带特定密码共享</h3><blockquote><p>smbpasswd</p></blockquote><h4 id="拷贝文件夹到远程服务器"><a href="#拷贝文件夹到远程服务器" class="headerlink" title="拷贝文件夹到远程服务器"></a>拷贝文件夹到远程服务器</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">scp -r /home/ubuntu/train_ssd_mobilenet/output-0530 服务器系统用户名@服务器公网ip:/home/liujie/tensorflow/models</span><br></pre></td></tr></table></figure><h3 id="设置代理："><a href="#设置代理：" class="headerlink" title="设置代理："></a>设置代理：</h3><h6 id="全局代理"><a href="#全局代理" class="headerlink" title="全局代理"></a>全局代理</h6><p>git config –global http.proxy 127.0.0.1:1087</p><h6 id="局部代理，在github-clone-仓库内执行"><a href="#局部代理，在github-clone-仓库内执行" class="headerlink" title="局部代理，在github clone 仓库内执行"></a>局部代理，在github clone 仓库内执行</h6><p>git config –local http.proxy 127.0.0.1:1087<br>(127.0.0.1:1087 这个地址是我翻出去用的代理地址，根据自己的实际修改)</p><h3 id="查询是否使用代理："><a href="#查询是否使用代理：" class="headerlink" title="查询是否使用代理："></a>查询是否使用代理：</h3><h6 id="查询全局代理"><a href="#查询全局代理" class="headerlink" title="查询全局代理"></a>查询全局代理</h6><p>git config –global http.proxy</p><h6 id="查询局部代理"><a href="#查询局部代理" class="headerlink" title="查询局部代理"></a>查询局部代理</h6><p>git config –local http.proxy</p><h3 id="取消代理："><a href="#取消代理：" class="headerlink" title="取消代理："></a>取消代理：</h3><p>git config –global –unset http.proxy<br>git config –local –unset http.proxy</p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 技巧 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>let、with、run、apply、also函数的使用</title>
      <link href="/2020/02/05/let%E3%80%81with%E3%80%81run%E3%80%81apply%E3%80%81also%E5%87%BD%E6%95%B0%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
      <url>/2020/02/05/let%E3%80%81with%E3%80%81run%E3%80%81apply%E3%80%81also%E5%87%BD%E6%95%B0%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<p><em>简述:</em></p><p>相比Java, Kotlin提供了不少高级语法特性。对于一个Kotlin的初学者来说经常会写出一些不够优雅的代码。在Kotlin中的源码标准库(<a href="https://github.com/JetBrains/kotlin/blob/master/libraries/stdlib/src/kotlin/util/Standard.kt" target="_blank" rel="noopener">Standard.kt</a>)中提供了一些Kotlin扩展的内置函数可以优化kotlin的编码。Standard.kt是Kotlin库的一部分，它定义了一些基本函数。 这个源代码文件虽然一共不到50行代码，但是这些函数功能都非常强大。</p><hr><blockquote><p>转载于：<a href="https://blog.csdn.net/u013064109/article/details/78786646" target="_blank" rel="noopener">https://blog.csdn.net/u013064109/article/details/78786646</a></p></blockquote><h3 id="一、回调函数的Kotin的lambda的简化"><a href="#一、回调函数的Kotin的lambda的简化" class="headerlink" title="一、回调函数的Kotin的lambda的简化"></a>一、回调函数的Kotin的lambda的简化</h3><p>在Kotlin中对Java中的一些的接口的回调做了一些优化，可以使用一个lambda函数来代替。可以简化写一些不必要的嵌套回调方法。但是需要注意:<strong>在lambda表达式，只支持单抽象方法模型，也就是说设计的接口里面只有一个抽象的方法，才符合lambda表达式的规则，多个回调方法不支持。</strong></p><ul><li><p>1、用Java代码实现一个接口的回调。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mView.setEventListener(<span class="keyword">new</span> ExamPlanHomeEventListener()&#123;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onSuccess</span><span class="params">(Data data)</span></span>&#123;</span><br><span class="line">     <span class="comment">//todo</span></span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li><li><p>2、在Kotlin中的实现一个接口的回调,不使用lambda表达式(这种方式非常适用于kotlin中对于一个接口中含有多个回调方法)。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mView.setEventListener(object: ExamPlanHomeEventListener&#123;</span><br><span class="line">     </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onSuccess</span><span class="params">(Data data)</span></span>&#123;</span><br><span class="line">      <span class="comment">//todo</span></span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li><li><p>3、如果在Kotlin中的对于<strong>接口只有一个回调的方法</strong>，就符合使用lambda函数，我们可以把以上代码简化成这样。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">mView.setEventListener(&#123;</span><br><span class="line">   data: Data -&gt;</span><br><span class="line">   <span class="comment">//todo</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">//或者可以直接省略Data,借助kotlin的智能类型推导</span></span><br><span class="line"></span><br><span class="line">mView.setEventListener(&#123;</span><br><span class="line">   data -&gt;</span><br><span class="line">   <span class="comment">//todo</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li><li><p>4、如果以上代码中的<strong>data参数没有使用</strong>到的话，可以直接把data去掉</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mView.setEventListener(&#123;</span><br><span class="line">  <span class="comment">//todo</span></span><br><span class="line"></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li><li><p>5、以上代码还可以做个调整，由于setEventListener函数<strong>最后一个参数是一个函数</strong>的话，可以直接把括号的实现提到圆括号外面</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mView.setEventListener()&#123;</span><br><span class="line">   //todo</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>6、由于setEventListener这个函数<strong>只有一个参数</strong>，可以直接省略圆括号</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mView.setEventListener&#123;</span><br><span class="line">  //todo</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="二、内联扩展函数之let"><a href="#二、内联扩展函数之let" class="headerlink" title="二、内联扩展函数之let"></a>二、内联扩展函数之let</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">let扩展函数的实际上是一个作用域函数，当你需要去定义一个变量在一个特定的作用域范围内，let函数的是一个不错的选择；let函数另一个作用就是可以避免写一些判断null的操作。</span><br></pre></td></tr></table></figure><ul><li>1、let函数的使用的一般结构</li></ul><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">object</span>.let&#123;</span><br><span class="line">   it.todo()<span class="comment">//在函数体内使用it替代object对象去访问其公有的属性和方法</span></span><br><span class="line">   ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//另一种用途 判断object为null的操作</span></span><br><span class="line"><span class="keyword">object</span>?.let&#123;<span class="comment">//表示object不为null的条件下，才会去执行let函数体</span></span><br><span class="line">   it.todo()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>2、let函数底层的inline扩展函数+lambda结构</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">  @kotlin.internal.InlineOnly</span><br><span class="line">public inline fun &lt;T, R&gt; T.let(block: (T) -&gt; R): R = block(this)</span><br></pre></td></tr></table></figure><ul><li><p>3、let函数inline结构的分析</p><p>从源码let函数的结构来看它是只有一个lambda函数块block作为参数的函数,调用T类型对象的let函数，则该对象为函数的参数。在函数块内可以通过 it 指代该对象。返回值为函数块的最后一行或指定return表达式。</p></li><li><p>4、let函数的kotlin和Java转化</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">//kotlin</span></span><br><span class="line"> </span><br><span class="line"> <span class="function">fun <span class="title">main</span><span class="params">(args: Array&lt;String&gt;)</span> </span>&#123;</span><br><span class="line">    val result = <span class="string">"testLet"</span>.let &#123;</span><br><span class="line">        println(it.length)</span><br><span class="line">        <span class="number">1000</span></span><br><span class="line">    &#125;</span><br><span class="line">    println(result)</span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line"> <span class="comment">//java</span></span><br><span class="line"> </span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">LetFunctionKt</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(@NotNull String[] args)</span> </span>&#123;</span><br><span class="line">      Intrinsics.checkParameterIsNotNull(args, <span class="string">"args"</span>);</span><br><span class="line">      String var2 = <span class="string">"testLet"</span>;</span><br><span class="line">      <span class="keyword">int</span> var4 = var2.length();</span><br><span class="line">      System.out.println(var4);</span><br><span class="line">      <span class="keyword">int</span> result = <span class="number">1000</span>;</span><br><span class="line">      System.out.println(result);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>5、let函数适用的场景</p><p><strong>场景一:</strong> 最常用的场景就是使用let函数处理需要针对一个可null的对象统一做判空处理。</p><p><strong>场景二:</strong> 然后就是需要去明确一个变量所处特定的作用域范围内可以使用</p></li><li><p>6、let函数使用前后的对比</p><p>没有使用let函数的代码是这样的，看起来不够优雅</p></li></ul><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mVideoPlayer?.setVideoView(activity.course_video_view)</span><br><span class="line">mVideoPlayer?.setControllerView(activity.course_video_controller_view)</span><br><span class="line">mVideoPlayer?.setCurtainView(activity.course_video_curtain_view)</span><br></pre></td></tr></table></figure><p>使用let函数后的代码是这样的<br>​<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mVideoPlayer?.let &#123;</span><br><span class="line">it.setVideoView(activity.course_video_view)</span><br><span class="line">it.setControllerView(activity.course_video_controller_view)</span><br><span class="line">it.setCurtainView(activity.course_video_curtain_view)</span><br><span class="line">&#125;</span><br><span class="line">​</span><br></pre></td></tr></table></figure></p><h3 id="三、内联函数之with"><a href="#三、内联函数之with" class="headerlink" title="三、内联函数之with"></a>三、内联函数之with</h3><ul><li><p>1、with函数使用的一般结构</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">with(<span class="keyword">object</span>)&#123;</span><br><span class="line">  <span class="comment">//todo</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>2、with函数底层的inline扩展函数+lambda结构</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">@kotlin.internal.InlineOnly</span><br><span class="line">public inline fun &lt;T, R&gt; with(receiver: T, block: T.() -&gt; R): R = receiver.block()</span><br></pre></td></tr></table></figure></li><li><p>3、with函数inline结构的分析</p></li></ul><p>with函数和前面的几个函数使用方式略有不同，因为它不是以扩展的形式存在的。它是将某对象作为函数的参数，在函数块内可以通过 this 指代该对象。返回值为函数块的最后一行或指定return表达式。</p><p>可以看出with函数是接收了两个参数，分别为T类型的对象receiver和一个lambda函数块，所以with函数最原始样子如下:<br>​<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> result = with(user, &#123;</span><br><span class="line">    println(<span class="string">"my name is <span class="variable">$name</span>, I am <span class="variable">$age</span> years old, my phone number is <span class="variable">$phoneNum</span>"</span>)</span><br><span class="line">    <span class="number">1000</span></span><br><span class="line"> &#125;)</span><br><span class="line">​</span><br></pre></td></tr></table></figure></p><p>但是由于with函数最后一个参数是一个函数，可以把函数提到圆括号的外部，所以最终with函数的调用形式如下:</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> result = with(user) &#123;</span><br><span class="line">    println(<span class="string">"my name is <span class="variable">$name</span>, I am <span class="variable">$age</span> years old, my phone number is <span class="variable">$phoneNum</span>"</span>)</span><br><span class="line">    <span class="number">1000</span></span><br><span class="line">&#125;</span><br><span class="line">​</span><br></pre></td></tr></table></figure><ul><li><p>4、with函数的kotlin和Java转化</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">//kotlin</span><br><span class="line"></span><br><span class="line">fun main(args: Array&lt;String&gt;) &#123;</span><br><span class="line">    val user = User(&quot;Kotlin&quot;, 1, &quot;1111111&quot;)</span><br><span class="line"></span><br><span class="line">    val result = with(user) &#123;</span><br><span class="line">        println(&quot;my name is $name, I am $age years old, my phone number is $phoneNum&quot;)</span><br><span class="line">        1000</span><br><span class="line">    &#125;</span><br><span class="line">    println(&quot;result: $result&quot;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//java</span><br><span class="line"></span><br><span class="line"> public static final void main(@NotNull String[] args) &#123;</span><br><span class="line">      Intrinsics.checkParameterIsNotNull(args, &quot;args&quot;);</span><br><span class="line">      User user = new User(&quot;Kotlin&quot;, 1, &quot;1111111&quot;);</span><br><span class="line">      String var4 = &quot;my name is &quot; + user.getName() + &quot;, I am &quot; + user.getAge() + &quot; years old, my phone number is &quot; + user.getPhoneNum();</span><br><span class="line">      System.out.println(var4);</span><br><span class="line">      int result = 1000;</span><br><span class="line">      String var3 = &quot;result: &quot; + result;</span><br><span class="line">      System.out.println(var3);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></li><li><p>5、with函数的适用的场景</p></li></ul><p>适用于调用同一个类的多个方法时，可以省去类名重复，直接调用类的方法即可，经常用于Android中RecyclerView中onBinderViewHolder中，数据model的属性映射到UI上</p><ul><li>6、with函数使用前后的对比<br>没有使用kotlin中的实现</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public void onBindViewHolder(ViewHolder holder, int position) &#123;</span><br><span class="line">    ArticleSnippet item = getItem(position);</span><br><span class="line">if (item == null) &#123;</span><br><span class="line">return;</span><br><span class="line">&#125;</span><br><span class="line">holder.tvNewsTitle.setText(StringUtils.trimToEmpty(item.titleEn));</span><br><span class="line">holder.tvNewsSummary.setText(StringUtils.trimToEmpty(item.summary));</span><br><span class="line">String gradeInfo = "难度：" + item.gradeInfo;</span><br><span class="line">String wordCount = "单词数：" + item.length;</span><br><span class="line">String reviewNum = "读后感：" + item.numReviews;</span><br><span class="line">String extraInfo = gradeInfo + " | " + wordCount + " | " + reviewNum;</span><br><span class="line">holder.tvExtraInfo.setText(extraInfo);</span><br><span class="line">//...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>kotlin的实现<br>​<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">override fun onBindViewHolder(holder: ViewHolder, <span class="attr">position</span>: Int)&#123;</span><br><span class="line">   val item = getItem(position)?: <span class="keyword">return</span></span><br><span class="line">   <span class="keyword">with</span>(item)&#123;</span><br><span class="line">      holder.tvNewsTitle.text = StringUtils.trimToEmpty(titleEn)</span><br><span class="line">  holder.tvNewsSummary.text = StringUtils.trimToEmpty(summary)</span><br><span class="line">  holder.tvExtraInf.text = <span class="string">"难度：$gradeInfo | 单词数：$length | 读后感: $numReviews"</span></span><br><span class="line">      <span class="comment">//...   </span></span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="四、内联扩展函数之run"><a href="#四、内联扩展函数之run" class="headerlink" title="四、内联扩展函数之run"></a>四、内联扩展函数之run</h3><ul><li><p>1、run函数使用的一般结构</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">object.run&#123;</span><br><span class="line">//todo</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>2、run函数的inline+lambda结构</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">@kotlin.internal.InlineOnly</span><br><span class="line">public inline fun &lt;T, R&gt; T.run(block: T.() -&gt; R): R = block()</span><br></pre></td></tr></table></figure></li><li><p>3、run函数的inline结构分析</p><p>run函数实际上可以说是let和with两个函数的结合体，run函数只接收一个lambda函数为参数，以闭包形式返回，返回值为最后一行的值或者指定的return的表达式。</p></li><li><p>4、run函数的kotlin和Java转化</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">//kotlin</span><br><span class="line"></span><br><span class="line">fun main(args: Array&lt;String&gt;) &#123;</span><br><span class="line">    val user = User(&quot;Kotlin&quot;, 1, &quot;1111111&quot;)</span><br><span class="line"></span><br><span class="line">    val result = user.run &#123;</span><br><span class="line">        println(&quot;my name is $name, I am $age years old, my phone number is $phoneNum&quot;)</span><br><span class="line">        1000</span><br><span class="line">    &#125;</span><br><span class="line">    println(&quot;result: $result&quot;)</span><br><span class="line">&#125;</span><br><span class="line">//java</span><br><span class="line"></span><br><span class="line">  public static final void main(@NotNull String[] args) &#123;</span><br><span class="line">      Intrinsics.checkParameterIsNotNull(args, &quot;args&quot;);</span><br><span class="line">      User user = new User(&quot;Kotlin&quot;, 1, &quot;1111111&quot;);</span><br><span class="line">      String var5 = &quot;my name is &quot; + user.getName() + &quot;, I am &quot; + user.getAge() + &quot; years old, my phone number is &quot; + user.getPhoneNum();</span><br><span class="line">      System.out.println(var5);</span><br><span class="line">      int result = 1000;</span><br><span class="line">      String var3 = &quot;result: &quot; + result;</span><br><span class="line">      System.out.println(var3);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></li><li><p>5、run函数的适用场景</p></li></ul><p>适用于let,with函数任何场景。因为run函数是let,with两个函数结合体，准确来说它弥补了let函数在函数体内必须使用it参数替代对象，在run函数中可以像with函数一样可以省略，直接访问实例的公有属性和方法，另一方面它弥补了with函数传入对象判空问题，在run函数中可以像let函数一样做判空处理</p><ul><li>6、run函数使用前后的对比</li></ul><p>还是借助上个例子kotlin代码<br>​<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onBindViewHolder</span><span class="params">(holder: <span class="type">ViewHolder</span>, position: <span class="type">Int</span>)</span></span>&#123;</span><br><span class="line">   <span class="keyword">val</span> item = getItem(position)?: <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">   with(item)&#123;</span><br><span class="line"></span><br><span class="line">      holder.tvNewsTitle.text = StringUtils.trimToEmpty(titleEn)</span><br><span class="line">       holder.tvNewsSummary.text = StringUtils.trimToEmpty(summary)</span><br><span class="line">       holder.tvExtraInf = <span class="string">"难度：<span class="variable">$gradeInfo</span> | 单词数：<span class="variable">$length</span> | 读后感: <span class="variable">$numReviews</span>"</span></span><br><span class="line">       ...   </span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>使用run函数后的优化</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">override fun onBindViewHolder(holder: ViewHolder, position: Int)&#123;</span><br><span class="line">  getItem(position)?.run&#123;</span><br><span class="line">      holder.tvNewsTitle.text = StringUtils.trimToEmpty(titleEn)</span><br><span class="line">   holder.tvNewsSummary.text = StringUtils.trimToEmpty(summary)</span><br><span class="line">   holder.tvExtraInf = &quot;难度：$gradeInfo | 单词数：$length | 读后感: $numReviews&quot;</span><br><span class="line">       ...   </span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="五、内联扩展函数之apply"><a href="#五、内联扩展函数之apply" class="headerlink" title="五、内联扩展函数之apply"></a>五、内联扩展函数之apply</h3><ul><li>1、apply函数使用的一般结构</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">object.apply&#123;</span><br><span class="line">//todo</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>2、apply函数的inline+lambda结构</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">@kotlin.internal.InlineOnly</span><br><span class="line">public inline fun &lt;T&gt; T.apply(block: T.() -&gt; Unit): T &#123; block(); return this &#125;</span><br></pre></td></tr></table></figure></li><li><p>3、apply函数的inline结构分析</p></li></ul><p>从结构上来看apply函数和run函数很像，唯一不同点就是它们各自返回的值不一样，run函数是以闭包形式返回最后一行代码的值，而apply函数的返回的是传入对象的本身。</p><ul><li><p>4、apply函数的kotlin和Java转化</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">//kotlin</span><br><span class="line"></span><br><span class="line">fun main(args: Array&lt;String&gt;) &#123;</span><br><span class="line">    val user = User(&quot;Kotlin&quot;, 1, &quot;1111111&quot;)</span><br><span class="line"></span><br><span class="line">    val result = user.apply &#123;</span><br><span class="line">        println(&quot;my name is $name, I am $age years old, my phone number is $phoneNum&quot;)</span><br><span class="line">        1000</span><br><span class="line">    &#125;</span><br><span class="line">    println(&quot;result: $result&quot;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//java</span><br><span class="line"></span><br><span class="line">public final class ApplyFunctionKt &#123;</span><br><span class="line">   public static final void main(@NotNull String[] args) &#123;</span><br><span class="line">      Intrinsics.checkParameterIsNotNull(args, &quot;args&quot;);</span><br><span class="line">      User user = new User(&quot;Kotlin&quot;, 1, &quot;1111111&quot;);</span><br><span class="line">      String var5 = &quot;my name is &quot; + user.getName() + &quot;, I am &quot; + user.getAge() + &quot; years old, my phone number is &quot; + user.getPhoneNum();</span><br><span class="line">      System.out.println(var5);</span><br><span class="line">      String var3 = &quot;result: &quot; + user;</span><br><span class="line">      System.out.println(var3);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>5、apply函数的适用场景</p></li></ul><p>整体作用功能和run函数很像，唯一不同点就是它返回的值是对象本身，而run函数是一个闭包形式返回，返回的是最后一行的值。正是基于这一点差异它的适用场景稍微与run函数有点不一样。apply一般用于一个对象实例初始化的时候，需要对对象中的属性进行赋值。或者动态inflate出一个XML的View的时候需要给View绑定数据也会用到，这种情景非常常见。特别是在我们开发中会有一些数据model向View model转化实例化的过程中需要用到。</p><ul><li>6、apply函数使用前后的对比<br>没有使用apply函数的代码是这样的，看起来不够优雅<br>​<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">mSheetDialogView = View.inflate(activity, R.layout.biz_exam_plan_layout_sheet_inner, <span class="keyword">null</span>)</span><br><span class="line">        mSheetDialogView.course_comment_tv_label.paint.isFakeBoldText = <span class="keyword">true</span></span><br><span class="line">        mSheetDialogView.course_comment_tv_score.paint.isFakeBoldText = <span class="keyword">true</span></span><br><span class="line">        mSheetDialogView.course_comment_tv_cancel.paint.isFakeBoldText = <span class="keyword">true</span></span><br><span class="line">        mSheetDialogView.course_comment_tv_confirm.paint.isFakeBoldText = <span class="keyword">true</span></span><br><span class="line">        mSheetDialogView.course_comment_seek_bar.max = <span class="number">10</span></span><br><span class="line">        mSheetDialogView.course_comment_seek_bar.progress = <span class="number">0</span></span><br><span class="line">​</span><br></pre></td></tr></table></figure></li></ul><p>使用apply函数后的代码是这样的<br>​<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">mSheetDialogView = View.inflate(activity, R.layout.biz_exam_plan_layout_sheet_inner, <span class="literal">null</span>).apply&#123;</span><br><span class="line">   course_comment_tv_label.paint.isFakeBoldText = <span class="literal">true</span></span><br><span class="line">   course_comment_tv_score.paint.isFakeBoldText = <span class="literal">true</span></span><br><span class="line">   course_comment_tv_cancel.paint.isFakeBoldText = <span class="literal">true</span></span><br><span class="line">   course_comment_tv_confirm.paint.isFakeBoldText = <span class="literal">true</span></span><br><span class="line">   course_comment_seek_bar.max = <span class="number">10</span></span><br><span class="line">   course_comment_seek_bar.progress = <span class="number">0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>多层级判空问题<br>​<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">if (mSectionMetaData == null || mSectionMetaData.questionnaire == null || mSectionMetaData.section == null) &#123;</span><br><span class="line">return;</span><br><span class="line">&#125;</span><br><span class="line">if (mSectionMetaData.questionnaire.userProject != null) &#123;</span><br><span class="line">renderAnalysis();</span><br><span class="line">return;</span><br><span class="line">&#125;</span><br><span class="line">if (mSectionMetaData.section != null &amp;&amp; !mSectionMetaData.section.sectionArticles.isEmpty()) &#123;</span><br><span class="line">fetchQuestionData();</span><br><span class="line">return;</span><br><span class="line">&#125;</span><br><span class="line">​</span><br></pre></td></tr></table></figure></p><p>kotlin的apply函数优化</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">mSectionMetaData?.apply&#123;</span><br><span class="line"><span class="comment">//mSectionMetaData不为空的时候操作mSectionMetaData</span></span><br><span class="line">&#125;?.questionnaire?.apply&#123;</span><br><span class="line"><span class="comment">//questionnaire不为空的时候操作questionnaire</span></span><br><span class="line">&#125;?.section?.apply&#123;</span><br><span class="line"><span class="comment">//section不为空的时候操作section</span></span><br><span class="line">&#125;?.sectionArticle?.apply&#123;</span><br><span class="line"><span class="comment">//sectionArticle不为空的时候操作sectionArticle</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="六、内联扩展函数之also"><a href="#六、内联扩展函数之also" class="headerlink" title="六、内联扩展函数之also"></a>六、内联扩展函数之also</h3><ul><li><p>1、also函数使用的一般结构</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">object.also&#123;</span><br><span class="line">//todo</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>2、also函数的inline+lambda结构</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">  @kotlin.internal.InlineOnly</span><br><span class="line"></span><br><span class="line">@SinceKotlin(“1.1”)</span><br><span class="line">public inline fun T.also(block: (T) -&gt; Unit): T &#123; block(this); return this &#125;</span><br></pre></td></tr></table></figure></li></ul><ul><li>3、also函数的inline结构分析</li></ul><p>also函数的结构实际上和let很像唯一的区别就是返回值的不一样，let是以闭包的形式返回，返回函数体内最后一行的值，如果最后一行为空就返回一个Unit类型的默认值。而also函数返回的则是传入对象的本身</p><ul><li><p>4、also函数编译后的class文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">//Kotlin</span><br><span class="line"></span><br><span class="line">fun main(args: Array&lt;String&gt;) &#123;</span><br><span class="line">    val result = &quot;testLet&quot;.also &#123;</span><br><span class="line">        println(it.length)</span><br><span class="line">        1000</span><br><span class="line">    &#125;</span><br><span class="line">    println(result)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//java</span><br><span class="line"></span><br><span class="line">public final class AlsoFunctionKt &#123;</span><br><span class="line">   public static final void main(@NotNull String[] args) &#123;</span><br><span class="line">      Intrinsics.checkParameterIsNotNull(args, &quot;args&quot;);</span><br><span class="line">      String var2 = &quot;testLet&quot;;</span><br><span class="line">      int var4 = var2.length();</span><br><span class="line">      System.out.println(var4);</span><br><span class="line">      System.out.println(var2);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>5、also函数的适用场景</p><p>适用于let函数的任何场景，also函数和let很像，只是唯一的不同点就是let函数最后的返回值是最后一行的返回值而also函数的返回值是返回当前的这个对象。一般可用于多个扩展函数链式调用</p></li><li><p>6、also函数使用前后的对比</p><p>和let函数类似</p></li></ul><h3 id="七、let-with-run-apply-also函数区别"><a href="#七、let-with-run-apply-also函数区别" class="headerlink" title="七、let,with,run,apply,also函数区别"></a>七、let,with,run,apply,also函数区别</h3><p>通过以上几种函数的介绍，可以很方便优化kotlin中代码编写，整体看起来几个函数的作用很相似，但是各自又存在着不同。使用的场景有相同的地方比如run函数就是let和with的结合体。下面一张表格可以清晰对比出他们的不同之处。</p><table><thead><tr><th>函数名</th><th>定义inline的结构</th><th>函数体内使用的对象</th><th>返回值</th><th>是否是扩展函数</th><th>适用的场景</th></tr></thead><tbody><tr><td>let</td><td>fun &lt;T, R&gt; T.let(block: (T) -&gt; R): R = block(this)</td><td>it指代当前对象</td><td>闭包形式返回</td><td>是</td><td>适用于处理不为null的操作场景</td></tr><tr><td>with</td><td>fun &lt;T, R&gt; with(receiver: T, block: T.() -&gt; R): R = receiver.block()</td><td>this指代当前对象或者省略</td><td>闭包形式返回</td><td>否</td><td>适用于调用同一个类的多个方法时，可以省去类名重复，直接调用类的方法即可，经常用于Android中RecyclerView中onBinderViewHolder中，数据model的属性映射到UI上</td></tr><tr><td>run</td><td>fun &lt;T, R&gt; T.run(block: T.() -&gt; R): R = block()</td><td>this指代当前对象或者省略</td><td>闭包形式返回</td><td>是</td><td>适用于let,with函数任何场景。</td></tr><tr><td>apply</td><td>fun T.apply(block: T.() -&gt; Unit): T { block(); return this }</td><td>this指代当前对象或者省略</td><td>返回this</td><td>是</td><td>1、适用于run函数的任何场景，一般用于初始化一个对象实例的时候，操作对象属性，并最终返回这个对象。 2、动态inflate出一个XML的View的时候需要给View绑定数据也会用到. 3、一般可用于多个扩展函数链式调用  4、数据model多层级包裹判空处理的问题</td></tr><tr><td>also</td><td>fun T.also(block: (T) -&gt; Unit): T { block(this); return this }</td><td>it指代当前对象</td><td>返回this</td><td>是</td><td>适用于let函数的任何场景，一般可用于多个扩展函数链式调用</td></tr><tr><td>```</td><td></td><td></td><td></td><td></td><td></td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Kotlin </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>RxJava2-入门</title>
      <link href="/2020/02/04/RxJava2-%E5%85%A5%E9%97%A8/"/>
      <url>/2020/02/04/RxJava2-%E5%85%A5%E9%97%A8/</url>
      
        <content type="html"><![CDATA[<p> Rxjava2</p><p> 基本使用</p><p> 常见操作符的使用</p><p> 与RxAndroid的结合</p><p> 与Retrofit2的结合</p><p> 封装 Kotlin + MVP +　Retrofit2 +　Rxjava2 + RxAndroid</p>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Kotlin </tag>
            
            <tag> RxJava </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Balloon Picker 气球选择器</title>
      <link href="/2019/11/13/Android-kt-balloon-picker/"/>
      <url>/2019/11/13/Android-kt-balloon-picker/</url>
      
        <content type="html"><![CDATA[<p>基于ViewGroup，用Kotlin实现的气球选择器，动态气球大小、拖拽交互，demo见文末</p><p align="center">    <img src="https://github.com/fairytale110/BalloonPicker/blob/master/blogpost/image/preview.gif?raw=true" height="500">    </p><p align="center">        <em>preview</em>    </p><p></p> <h2 id="控件拆分："><a href="#控件拆分：" class="headerlink" title="控件拆分："></a>控件拆分：</h2><table><thead><tr><th>元素</th><th>拆分</th><th>效果</th></tr></thead><tbody><tr><td>基线</td><td>已选择、未选择</td><td>根据触摸块改变长度</td></tr><tr><td>触摸块</td><td>触摸动画、内外圆</td><td>触摸时，内外圆按各自约束匀速放大；结束时，内外圆按各自约束匀速缩小</td></tr><tr><td>气球</td><td>缩放、位移</td><td>触摸前后缩放，移动时，匀速移动，中心旋转</td></tr><tr><td>文本</td><td>描述、值回调</td><td>普通文本、触摸显示回调值</td></tr></tbody></table><h2 id="绘制流程拆分"><a href="#绘制流程拆分" class="headerlink" title="绘制流程拆分"></a>绘制流程拆分</h2><h3 id="绘制基线和触摸块"><a href="#绘制基线和触摸块" class="headerlink" title="绘制基线和触摸块"></a>绘制基线和触摸块</h3><pre><code>分别绘制选中和未选中的基线然后绘制触摸块外圆和内圆 </code></pre><p align="center">    <img src="https://github.com/fairytale110/BalloonPicker/blob/master/blogpost/image/%E7%BB%98%E5%88%B6%E5%9F%BA%E7%BA%BF%E5%92%8C%E8%A7%A6%E6%91%B8%E5%9D%97.png?raw=true.png" width="500">    </p><p align="center">        <em>绘制基线和触摸块</em>    </p><p></p> <h3 id="为触摸块添加动画"><a href="#为触摸块添加动画" class="headerlink" title="为触摸块添加动画"></a>为触摸块添加动画</h3><h4 id="触摸块样式动画"><a href="#触摸块样式动画" class="headerlink" title="触摸块样式动画"></a>触摸块样式动画</h4><p> 以外圆圆心为中心，达到半径100像素范围内的触摸点，均可触发内圆缩放动画。</p><p> 1、默认触摸状态下，动画以默认半径开始匀速递增，同时刷新视图，直到最大内圆半径为止。 </p><p> 2、放大过程中，如果用户手指离开屏幕，触发MOVE_UP事件，则停止已有放大动画，转而执行缩小内圆半径的动画，直到达到最小内圆半径为止。</p><p> 3、如果缩小过程中用户再次触摸此区域，则重复执行过程1，以此达到跟随交互效果。</p><p> 同理，外圆的缩放规则遵循上述规则</p><p> 为了让动画效果更加平顺，并且不浪费太多时间在缩放过程中，我们将在缩放开始前结束已在执行中的动画，并重新计算剩余缩放过程需要的时间差，用于当前缩放过程。</p><p> 缩放动画时间差计算公式：</p><blockquote><p>实际动画持续时间 = 动画持续时间 * 剩余缩(放)距离/总缩(放)距离</p></blockquote> <figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">val</span> remainingTime: <span class="built_in">Long</span> = <span class="keyword">when</span> &#123;</span><br><span class="line">                <span class="keyword">this</span>.increase -&gt; (duration* (thumbInnerCircleRadiusMax - thumbInnerCircleRadiusTemp)/(thumbInnerCircleRadiusMax - thumbInnerCircleRadiusDefault)).toLong()</span><br><span class="line">                <span class="keyword">else</span> -&gt; (duration* (thumbInnerCircleRadiusTemp - thumbInnerCircleRadiusDefault)/(thumbInnerCircleRadiusMax - thumbInnerCircleRadiusDefault)).toLong()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> <p align="center">    <img src="https://github.com/fairytale110/BalloonPicker/blob/master/blogpost/image/scaleanim.gif?raw=true" width="500">    </p><p align="center">        <em>触摸效果</em>    </p><p></p> <h4 id="触摸块位移"><a href="#触摸块位移" class="headerlink" title="触摸块位移"></a>触摸块位移</h4><p>当触发MOVE_MOVE时，根据触摸坐标x差值，更新触摸块的x坐标。同时，计算出此时选择器的value，更新两侧基线状态，并执行回调。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> x = pointOfThumbTemp.x + event.x - pointOfTouchDown.x</span><br><span class="line"></span><br><span class="line">pointOfThumb = PointF( <span class="keyword">if</span> (x &gt; xOfTrackLayerEnd) xOfTrackLayerEnd  <span class="keyword">else</span> ( <span class="keyword">if</span> (x &lt; xOfTrackLayerStart) xOfTrackLayerStart <span class="keyword">else</span> x), pointOfThumbTemp.y)</span><br><span class="line"></span><br><span class="line">selectedValue = (<span class="keyword">this</span>.minValue.toFloat() + (<span class="keyword">this</span>.maxValue.toFloat() - <span class="keyword">this</span>.minValue.toFloat()) * (pointOfThumb.x - xOfTrackLayerStart) / (widthOfView - <span class="number">2</span> * xOfTrackLayerStart)).toLong()</span><br><span class="line"></span><br><span class="line">postInvalidate()</span><br><span class="line"></span><br><span class="line">listener?.callBack(selectedValue)</span><br></pre></td></tr></table></figure><p align="center">    <img src="https://github.com/fairytale110/BalloonPicker/blob/master/blogpost/image/touchmotion.gif?raw=true" width="500">    </p><p align="center">        <em>触摸效果</em>    </p><p></p> <h3 id="气球动画"><a href="#气球动画" class="headerlink" title="气球动画"></a>气球动画</h3><p>通过拆分：<br>1、ACTION_MOVE，当触摸坐标发生位移，气球旋转对应角度以保持风力阻挡的惯性。气球中心点到基线的垂线，与气球中心点和触点中心点 的直线的夹角，即为当前状态下的旋转角度<br>//分析图</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">locationOfThumb</span><span class="params">(pointF: <span class="type">PointF</span>)</span></span> &#123;</span><br><span class="line">       pointThumb.<span class="keyword">set</span>(pointF.x, height.toFloat() - trackLayer?.getPadding()!!)</span><br><span class="line">       <span class="keyword">val</span> b = pointF.x - trackLayer?.getPadding()!!</span><br><span class="line">       <span class="keyword">val</span> angleRoTan = -atan(b/distanceVerticalBetweenBalloonAndTrackLayer) / PI  * <span class="number">180</span></span><br><span class="line">       L(<span class="string">"angleRoTan <span class="variable">$angleRoTan</span>"</span>)</span><br><span class="line">       balloon?.rotation = <span class="keyword">if</span> (angleRoTan.toFloat() &gt; <span class="number">0F</span> ) <span class="number">0F</span> <span class="keyword">else</span> angleRoTan.toFloat()</span><br><span class="line">       postInvalidate()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p align="center">    <img src="https://github.com/fairytale110/BalloonPicker/blob/master/blogpost/image/balloonrotation.gif?raw=true" width="500">    </p><p align="center">        <em>旋转气球（假装蓝色块是气球）</em>    </p><p></p> <p>此时气球能跟着“线”被“手”带”动“了，但是气球还没有移动，“线”也没有无限长，行，我们先让气球移动起来。</p><p>这里需要设定一个阀值，即“线”的长度，当超过这个阀值，则气球将被“拽着”移动。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">moveBalloon</span><span class="params">()</span></span>&#123;</span><br><span class="line">   <span class="keyword">val</span> ptb2 = (pointThumb.x - centerOfBalloon.x).toDouble().pow(<span class="number">2.0</span>)</span><br><span class="line">   <span class="keyword">val</span> c =  sqrt (ptb2 + centerOfBalloon.y * centerOfBalloon.y)</span><br><span class="line">   ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>直接计算“线”长来判断，但是这样需要繁琐的符号运算，这里我们可以直接找个参考数据，简化逻辑过程：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">moveBalloon</span><span class="params">()</span></span>&#123;</span><br><span class="line">   <span class="keyword">val</span> b = pointThumb.x - centerOfBalloon.x</span><br><span class="line">   ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过触点与气球中心点的垂直距离的变化来判断是否需要进行“拽着”移动：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">locationOfThumb</span><span class="params">(pointF: <span class="type">PointF</span>)</span></span> &#123;</span><br><span class="line">    pointThumb.<span class="keyword">set</span>(pointF.x, height.toFloat() - trackLayer?.getPadding()!!)</span><br><span class="line">    moveBalloon()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">moveBalloon</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">val</span> b = pointThumb.x - centerOfBalloon.x</span><br><span class="line">    <span class="keyword">val</span> ins = abs(b) - (height - pointThumb.y)</span><br><span class="line">    <span class="keyword">if</span> (b != <span class="number">0F</span> &amp;&amp; ins &gt; <span class="number">0</span>)&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">val</span> xOfBalloon = centerOfBalloon.x.toInt() - balloon?.layoutParams!!.width / <span class="number">2</span> + <span class="keyword">if</span> (b &gt; <span class="number">0</span>)  ins.toInt() <span class="keyword">else</span> - ins.toInt()</span><br><span class="line">        </span><br><span class="line">        balloon?.layout( xOfBalloon, balloon?.y!!.toInt(), xOfBalloon + balloon?.layoutParams!!.width, measuredHeight - trackLayer?.layoutParams!!.height)</span><br><span class="line">        </span><br><span class="line">        centerOfBalloon.<span class="keyword">set</span>(balloon?.x!! + balloon?.layoutParams!!.width / <span class="number">2F</span>,  balloon?.y!! + balloon?.layoutParams!!.height / <span class="number">2</span>)</span><br><span class="line">    </span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//TODO moveBalloonWithAnim</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> angleRoTan = -atan(b/distanceVerticalBetweenBalloonAndTrackLayer) / PI  * <span class="number">180</span></span><br><span class="line">    L(<span class="string">"angleRoTan <span class="variable">$angleRoTan</span>"</span>)</span><br><span class="line">    balloon?.rotation = angleRoTan.toFloat()</span><br><span class="line">    postInvalidate()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p align="center">    <img src="https://github.com/fairytale110/BalloonPicker/blob/master/blogpost/image/%E6%8B%96%E6%8B%BD%E6%B0%94%E7%90%83.gif?raw=true" width="500">    </p><p align="center">        <em>拖拽气球</em>    </p><p></p> <p>此时气球已经可以被拽着走了，为了让效果更加逼真，在阀值内，我们通过动画来缓慢移动，  </p><p>2、同时以匀速向新的圆点移动，直到气球中心x与触摸点x重合。<br>通过监听将TrackLayer的touch数据传递给pickerView，改造了统一的接口:</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">TrackLayerListener</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">fun</span> <span class="title">layerTouchedDown</span><span class="params">()</span></span></span><br><span class="line">   <span class="function"><span class="keyword">fun</span> <span class="title">layerTouchedUp</span><span class="params">()</span></span></span><br><span class="line">   <span class="function"><span class="keyword">fun</span> <span class="title">layerTouchedMoving</span><span class="params">(value : <span class="type">Long</span>, pointAtLayer : <span class="type">PointF</span>)</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 layerTouchedMoving() 中处理气球的移动逻辑.</p><p>当球心与圆点距离小于阀值时，中断气球动画，直接布局气球在picker中的位置；否则，执行新的气球动画:</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">layerTouchedMoving</span><span class="params">(value: <span class="type">Long</span>, pointAtLayer: <span class="type">PointF</span>)</span></span> &#123;</span><br><span class="line">       pointThumb.<span class="keyword">set</span>(pointAtLayer.x, height.toFloat() - trackLayer?.getPadding()!!)</span><br><span class="line">       <span class="keyword">val</span> b = pointThumb.x.toInt() - centerOfBalloon.x.toInt()</span><br><span class="line">       <span class="keyword">if</span> (abs(b) &gt; distanceVerticalBetweenBalloonAndTrackLayer.toInt())&#123;</span><br><span class="line">           initAnimation(ValueAnimator.ofInt(centerOfBalloon.x.toInt(), pointThumb.x.toInt()))</span><br><span class="line"></span><br><span class="line">           <span class="keyword">val</span> xOfBalloon = (centerOfBalloon.x - balloon?.layoutParams!!.width / <span class="number">2</span> + <span class="keyword">if</span> (b &gt; <span class="number">0</span>)  b-distanceVerticalBetweenBalloonAndTrackLayer <span class="keyword">else</span> b + distanceVerticalBetweenBalloonAndTrackLayer).toInt()</span><br><span class="line">           </span><br><span class="line">           balloon?.layout( xOfBalloon , balloon?.y!!.toInt(), xOfBalloon + balloon?.layoutParams!!.width, balloon?.y!!.toInt() +balloon?.layoutParams!!.height )</span><br><span class="line">           </span><br><span class="line">           centerOfBalloon.<span class="keyword">set</span>(xOfBalloon + balloon?.layoutParams!!.width / <span class="number">2F</span>,  balloon?.y!! + balloon?.layoutParams!!.height / <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">           rotateBalloon()</span><br><span class="line">       &#125;</span><br><span class="line">       moveBalloon()</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p align="center">    <img src="https://github.com/fairytale110/BalloonPicker/blob/master/blogpost/image/balloonfollow.gif?raw=true" width="500">    </p><p align="center">        <em>拖拽气球</em>    </p><p></p> <p>效果还可以，接下来就需要根据picker的取值来动态缩放气球，同时维持住气球的底部位置不变<br>本计划直接调用scale API， 奈何privot也需要动态控制，不然不能维持气球底部垂直位置不变。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">layerTouchedMoving</span><span class="params">(value: <span class="type">Long</span>, pointAtLayer: <span class="type">PointF</span>)</span></span> &#123;</span><br><span class="line">           <span class="comment">//...</span></span><br><span class="line">           <span class="keyword">val</span> valueAtBalloon =trackLayer?.minValue()!! +  (trackLayer?.maxValue()!! - trackLayer?.minValue()!!) *  centerOfBalloon.x/measuredWidth</span><br><span class="line">           </span><br><span class="line">           <span class="keyword">val</span> disScaleHeight = balloonHeightDefault * (valueAtBalloon - trackLayer?.minValue()!!) / (trackLayer?.maxValue()!! - trackLayer?.minValue()!!)</span><br><span class="line">           </span><br><span class="line">           <span class="keyword">val</span> disScaleWidth = balloonWidthDefault/<span class="number">2</span> * (valueAtBalloon - trackLayer?.minValue()!!) / (trackLayer?.maxValue()!! - trackLayer?.minValue()!!)</span><br><span class="line">           </span><br><span class="line">           <span class="comment">//...</span></span><br><span class="line">           balloon?.layout( xOfBalloon  , balloonDefaultY.toInt() - disScaleHeight.toInt(), xOfBalloon + balloonWidthDefault.toInt() + disScaleWidth.toInt() * <span class="number">2</span>, (balloonDefaultY + balloonHeightDefault).toInt())</span><br><span class="line">           centerOfBalloon.<span class="keyword">set</span>(xOfBalloon + disScaleWidth + balloonWidthDefault / <span class="number">2F</span>,  balloonDefaultY + balloonHeightDefault/<span class="number">2</span> - disScaleHeight/<span class="number">2</span> )</span><br><span class="line">           <span class="comment">//...</span></span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 给气球打上辅助线，我们来看下效果：<br> </p><p align="center"><br>     <img src="https://github.com/fairytale110/BalloonPicker/blob/master/blogpost/image/balloonScale.gif?raw=true" width="500"><br>     </p><p align="center"><br>         <em>拖拽气球</em><br>     </p><br> <p></p> <p></p><p>4、气球显示隐藏<br>气球能动能缩放了，接下来给气球加入出入动画，</p><p>默认情况下，不展示气球，当ACTION_DOWN 触发，气球冲圆点渐显 &amp; 放大 &amp; 移动 到初始位置；</p><p>当ACTION_UP 触发，气球从当前位置 淡出 &amp; 缩小 &amp; 移动 到圆点位置</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">layerTouchedDown</span><span class="params">()</span></span> &#123;</span><br><span class="line">        balloon?.startAnimation(BalloonAnimSet.create(<span class="literal">true</span>, <span class="number">0F</span>, <span class="number">0F</span>, pointThumb.y - balloon?.y!!, <span class="number">0F</span>, context , listenerEnter))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">layerTouchedUp</span><span class="params">()</span></span> &#123;</span><br><span class="line">        balloon?.visibility = View.INVISIBLE</span><br><span class="line">        pointThumb.<span class="keyword">set</span>(trackLayer?.centerPoint()!!.x, height.toFloat() - trackLayer?.getPadding()!!)</span><br><span class="line"></span><br><span class="line">        initAnimation(ValueAnimator.ofInt(centerOfBalloon.x.toInt(), pointThumb.x.toInt()))</span><br><span class="line"></span><br><span class="line">        moveBalloon()</span><br><span class="line">        balloon?.startAnimation(BalloonAnimSet.create(<span class="literal">false</span>, <span class="number">0F</span>, <span class="number">0F</span>, <span class="number">0F</span>, pointThumb.y - balloon?.y!!, context , listenerExit))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>来看看效果吧:<br> </p><p align="center"><br>     <img src="https://github.com/fairytale110/BalloonPicker/blob/master/blogpost/image/balloonshowanim.gif?raw=true" width="500"><br>     </p><p align="center"><br>         <em>拖拽气球</em><br>     </p><br> <p></p> <p></p><h2 id="开始使用"><a href="#开始使用" class="headerlink" title="开始使用"></a>开始使用</h2><p>修饰一下，抛出必要的样式设置方法，最终效果完成：<br>//使用方法</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">tech.nicesky.balloonpicker.BalloonPickerView</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:id</span>=<span class="string">"@+id/balloon_picker"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag"> /&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function">fun <span class="title">load</span><span class="params">()</span></span>&#123;</span><br><span class="line">     balloon_picker.layerValues(<span class="number">10</span>, <span class="number">50</span>, <span class="number">5</span>)</span><br><span class="line">     </span><br><span class="line">     balloon_picker.defaultValue(<span class="number">30</span>)</span><br><span class="line">     balloon_picker.setColorFoThumb(<span class="string">"#FFFFFF"</span>.toColorInt(), <span class="string">"#512DA8"</span>.toColorInt())</span><br><span class="line">     balloon_picker.setColorForLayer(<span class="string">"#512DA8"</span>.toColorInt(), <span class="string">"#BDBDBD"</span>.toColorInt())</span><br><span class="line">     balloon_picker.setColorForBalloon(<span class="string">"#512DA8"</span>.toColorInt())</span><br><span class="line">     balloon_picker.setColorForBalloonValue(<span class="string">"#FFFFFF"</span>.toColorInt())</span><br><span class="line">     balloon_picker.colorOfDesc = <span class="string">"#000000"</span>.toColorInt()</span><br><span class="line">     balloon_picker.colorOfValue = <span class="string">"#000000"</span>.toColorInt()</span><br><span class="line">     balloon_picker.desc = <span class="string">"Quantity"</span></span><br><span class="line">     balloon_picker.valueListener = object : BalloonPickerListener&#123;</span><br><span class="line">               <span class="function">override fun <span class="title">changed</span><span class="params">(value: Long)</span> </span>&#123;</span><br><span class="line">                      Log.w(<span class="string">"MainActivity"</span>,<span class="string">"value: $value"</span>)</span><br><span class="line">               &#125;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="comment">// val valueSelected = balloon_picker.getValue()</span></span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h2 id="THANKS"><a href="#THANKS" class="headerlink" title="THANKS"></a>THANKS</h2><p>All design and inspiration credits belongs to<br><a href="https://dribbble.com/shots/6549207-Balloon-Slider-Control" target="_blank" rel="noopener">Cuberto</a></p><blockquote><p>当然，这个控件还有很大的优化空间，欢迎诸位探讨。<br>GitHub：<a href="https://github.com/fairytale110/BalloonPicker" target="_blank" rel="noopener">https://github.com/fairytale110/BalloonPicker</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Kotlin </tag>
            
            <tag> Custom View </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>About_52pojie_IOS</title>
      <link href="/2016/06/01/About_52pojie_IOS/"/>
      <url>/2016/06/01/About_52pojie_IOS/</url>
      
        <content type="html"><![CDATA[<pre><code>&quot;吾爱破解&quot; IOS版，以下简称“本软件”。本软件不存在任何保存、复制等窃取个人账号信息的行为，仅作为吾爱论坛的一个壳子，方便大家日常签到、浏览帖子。本软件为本人个人作品，因AppStore开发者账号比较贵，本人未发布到AppStore，唯一下载渠道请移步吾爱破解官方论坛搜索“吾爱论坛APP IOS版”下载，其它任何途径下载的，出现问题请自行负责。</code></pre><p>   Powered by nicesky.tech</p>]]></content>
      
      
      <categories>
          
          <category> iOS </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Hello nicesky.tech</title>
      <link href="/2016/06/01/hello-nicesky/"/>
      <url>/2016/06/01/hello-nicesky/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
      
      
      <categories>
          
          <category> 杂记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 水 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
    
    
    <entry>
      <title>关于</title>
      <link href="/about/index.html"/>
      <url>/about/index.html</url>
      
        <content type="html"><![CDATA[<p>笔名：智灵。<br>Android 兼 iOS 移动开发工程师，4年经验，现居四川，独立开发。</p>]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>categories</title>
      <link href="/categories/index.html"/>
      <url>/categories/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>tags</title>
      <link href="/tags/index.html"/>
      <url>/tags/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
  
</search>
